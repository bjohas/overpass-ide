function osmTable(pContainer) {
  this.container = pContainer;
  this.value = "";
  
  //showing
  this.showIDs = true;
  this.showType = true;
  this.showGeometry = false;
  this.columns = [] //and attributes
  this.autoColumns = true; //if true, columns are auto-generated by the data whenever the data updates.
  
  this.setValue = function setValue(data) {
    this.value = data.getGeoJSON(); //this is a data array, that contains up to four featureCollections for different types (node, way, relation, area!?)
    this.generateTable();
  }
  
  this.generateWKT = function generateWkT(geometry) {
    var geo;
    if (geometry.type == "Point") {
      // POINT (30 10)
      return "POINT ("+geometry.coordinates[0] + " " + geometry.coordinates[1] + ")";
    }
    else if (geometry.type == "Polygon") {
      //POLYGON ((30 10, 10 20, 20 40, 40 40, 30 10))
      //POLYGON ((35 10, 10 20, 15 40, 45 45, 35 10),(20 30, 35 35, 30 20, 20 30))
      geo = "";
      //coordinates of a polygon are a 2d-array we have to use as such
      for (var i=0; i<geometry.coordinates.length; i++) {
        geo = geo + ",(";
        var poly = "";
        for (var j=0; j<geometry.coordinates[i].length; j++) {
          poly = poly + ", " + geometry.coordinates[i][j][0] + " " + geometry.coordinates[i][j][1];
        }
        geo = geo + poly.substr(2);
        geo = geo + ")";
      }
      geo = geo.substr(1); //cut the first ,
      
      return "POLYGON (" + geo + ")";
    }
    else if (geometry.type == "LineString") {
      geo = "";
      for (var i=0; i<geometry.coordinates.length; i++) {
        geo = geo + ", " + geometry.coordinates[i][0] + " " + geometry.coordinates[i][1];
      }
      geo = geo.substr(2); //cut the first ", "
      return "LINESTRING (" + geo + ")";
      // 	LINESTRING (30 10, 10 30, 40 40)
    }
    else if (geometry.type == "MultiPolygon") {
      geo = "";
      //the coordinates array in this case is 3-dimensional:
      //1) the individual multi-polygons (as they are 
      //2) the single ways
      //3) the nodes (as lon/lat)
      //for the WKT notation this means:
      for (var mp=0; mp<geometry.coordinates.length; mp++) {
        var mpoly = "";
        for (var p=0; p<geometry.coordinates[mp].length; p++) {
          var poly = "";
          for (var w=0; w<geometry.coordinates[mp][p].length; w++) {
            poly = poly + ", " + geometry.coordinates[mp][p][w][0] + " " + geometry.coordinates[mp][p][w][1];
          }
          mpoly = mpoly + ", (" + poly.substr(2) + ")";
          //mpoly = mpoly + ")";
        }
        geo = geo + ", (" + mpoly.substr(2) + ")";
      }
      return "MULTIPOLYGON (" + geo.substr(2) + ")";
      //MULTIPOLYGON (((30 20, 10 40, 45 40, 30 20)),
      //              ((15 5, 40 10, 10 20, 5 10, 15 5)))
    }
  };
  
  this.getPropertiesSortedByValue = function(obj) {
    var arr = [];
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        arr.push({ 'k': prop,
                   'v': obj[prop]
                 });
      }
    }
    arr.sort(function(a,b) { return b.v - a.v; }); //sort descending!
    for(var i=0; i<arr.length; i++) {
      arr[i] = arr[i].k;
    }
    return arr;
  }
  
  function isOverflowWidth(node) {
    var el = $(node);
    if (el.css("overflow") == "hidden") {
      var t = $(node.cloneNode(true));
      var content = document.createElement('span');
      content.appendChild(document.createTextNode(el.html()));
      $(content).appendTo($("#table .dataTables_wrapper"));
      function width() {
        return $(content).width() > el.width();
      };
      var result = width();
      content.remove();
      return result;
    }
    else {
      console.debug("no hidden overflow");
      return false;
    }
  }
  
  this.generateTable = function generateTable() {
    //replace the table object:
    $('#table').replaceWith('<div id="table"><table id="datatable"><thead></thead><tbody></tbody><tfoot><tr></tr></tfoot></table></div>');
    //calculate the right table from the objects:
    this.tabledata = [];
    this.tagcounts = {};
    //iterate over the featureCollections
    for (var i=0; i<this.value.length; i++) {
      for (var j=0; j<this.value[i].features.length; j++) {
        var feature = this.value[i].features[j];
        var fixedColumns = {};
        //the fixed columns:
        if (this.showIDs) { fixedColumns = $.extend({"__id__": feature.properties.id}, fixedColumns); }
        if (this.showType) { fixedColumns = $.extend({"__type__": feature.properties.type}, fixedColumns); }
        if (this.showGeometry) { fixedColumns = $.extend({"__geo__": this.generateWKT(feature.geometry)}, fixedColumns); }
        var item = $.extend(fixedColumns, feature.properties.tags );
        
        for(var tag in feature.properties.tags) {
          if (!this.tagcounts[tag]) {
            this.tagcounts[tag] = 0;
          }
          this.tagcounts[tag]++;
        }
        this.tabledata.push(item);
      }
    }
    //console.debug(this.tagcounts);
    //flush the table:
    $("#datatable thead").empty();
    $("#datatable tbody").empty();
    //get the table column definitions:
    var headers = []; //'osm-id','type','geometry'];
    var tagColumns = this.getPropertiesSortedByValue(this.tagcounts);
    var fields = [];
    if (this.showIDs) { fields.push('__id__'); headers.push('osm-id'); }
    if (this.showType) { fields.push('__type__'); headers.push('type'); }
    if (this.showGeometry) { fields.push('__geo__'); headers.push('geometry'); }

    headers  = headers.concat(tagColumns);
    fields = fields.concat(tagColumns);
    this.jsont = $("#datatable").jsonTable({
      head : headers, // Goes on the <thead>
      json : fields //json identities from the loaded json object
    });
    
    var options = {
                    source : this.tabledata, // Can be a URL or a JSON object array
                    rowClass : "rowClass", //(optional) Class to be applied
                    callback : function() {
                      // (optional) Do something when table is updated
                    }
                  };

    this.jsont.jsonTableUpdate(options);

    //get settings for the columns:
    var columnDefinitions = new Array(headers.length); //no setting for now
    //special case housenumbers:
    var hnrCol = headers.indexOf("addr:housenumber");
    if (hnrCol >= 0) {
      columnDefinitions[hnrCol] = {"sType": "housenumbers"};
    }

    //make sure that the datatable is empty:
    var table = $("#datatable").dataTable({"bJQueryUI": true, // applies the jquery-UI styling
                                           "iDisplayLength": 10, //default number of lines shown per page
                                           "oLanguage": { //custom strings in the UI
                                               "sSearch": "Search all columns:" //the global search box
                                             },
                                           "fnInitComplete": function() {
                                                               //delete the repeated captions - whyever these are there...
                                                               $('#datatable tfoot th').remove();
                                                               //add filter boxes:
                                                               var oSettings = $('#datatable').dataTable().fnSettings();
                                                               for ( var i=0 ; i<oSettings.aoPreSearchCols.length ; i++ ){
                                                                 var cap = $('#datatable thead th:nth-child('+(1+i)+')').text();
                                                                 //create the cell:
                                                                 $('#datatable tfoot tr').append('<td><input type="text"/></td>');
                                                                 $('#datatable tfoot td:last-child() input').attr('placeholder', 
                                                                                                                  cap).attr('value','');
                                                                 
                                                                 $("tfoot input")[i].className = "";
                                                               }
                                                             },
                                           "aoColumns": columnDefinitions //set column types where known
                                          });
    //filtering ability per column
    $("#datatable tfoot input").keyup(function() {
                                        table.fnFilter(this.value, $("tfoot input").index(this));
                                      });

    //set tooltips for all cells:
    $("#datatable tbody td").filter(function() { 
                                var overflowing = isOverflowWidth(this); 
                                return overflowing;
                              }
                             )
                      .tooltip({ content: function() { 
                                            return $(this).text() 
                                          }, 
                                 items: "td",
                                 tooltipClass: "table-tooltip"
                               });
  }
  
  //extend the sorting capabilities:
  
  //housenumber sorting functions:
  jQuery.fn.dataTableExt.oSort['housenumbers-asc']  = function(a,b) {
    var x = (a == "-") ? 0 : a.replace( /,/, "." );
    var y = (b == "-") ? 0 : b.replace( /,/, "." );
    x = parseFloat( x );
    y = parseFloat( y );
    return ((x < y) ? -1 : ((x > y) ?  1 : 0)); //x=a, y=b
  };
 
  jQuery.fn.dataTableExt.oSort['housenumbers-desc'] = function(a,b) {
    var x = (a == "-") ? 0 : a.replace( /,/, "." );
    var y = (b == "-") ? 0 : b.replace( /,/, "." );
    x = parseFloat( x );
    y = parseFloat( y );
    return ((x < y) ?  1 : ((x > y) ? -1 : 0));
  };

  return;
}
