function osmTable(pContainer) {
  this.container = pContainer;
  this.value = "";
  
  //showing
  this.showIDs = true;
  this.showType = true;
  this.columns = [] //and attributes
  this.autoColumns = true; //if true, columns are auto-generated by the data whenever the data updates.
  
  this.setValue = function setValue(data) {
    //console.debug(data);
    console.debug(data.getGeoJSON());
    this.value = data.getGeoJSON(); //this is a data array, that contains up to four featureCollections for different types (node, way, relation, area!?)
    this.generateTable();
  }
  
  this.generateWKT = function generateWkT(geometry) {
    var geo;
    if (geometry.type == "Point") {
      // POINT (30 10)
      return "POINT ("+geometry.coordinates[0] + " " + geometry.coordinates[1] + ")";
    }
    else if (geometry.type == "Polygon") {
      //POLYGON ((30 10, 10 20, 20 40, 40 40, 30 10))
      //POLYGON ((35 10, 10 20, 15 40, 45 45, 35 10),(20 30, 35 35, 30 20, 20 30))
      geo = "";
      //coordinates of a polygon are a 2d-array we have to use as such
      for (var i=0; i<geometry.coordinates.length; i++) {
        geo = geo + ",(";
        var poly = "";
        for (var j=0; j<geometry.coordinates[i].length; j++) {
          poly = poly + ", " + geometry.coordinates[i][j][0] + " " + geometry.coordinates[i][j][1];
        }
        geo = geo + poly.substr(2);
        geo = geo + ")";
      }
      geo = geo.substr(1); //cut the first ,
      
      return "POLYGON (" + geo + ")";
    }
    else if (geometry.type == "LineString") {
      geo = "";
      for (var i=0; i<geometry.coordinates.length; i++) {
        geo = geo + ", " + geometry.coordinates[i][0] + ", " + geometry.coordinates[i][1];
      }
      geo = geo.substr(2); //cut the first ", "
      return "LINESTRING (" + geo + ")";
      // 	LINESTRING (30 10, 10 30, 40 40)
    }
    else if (geometry.type == "MultiPolygon") {
      console.debug(geometry);
      geo = "";
      return "MULTIPOLYGON (" + geo + ")";
    }
  };
  
  this.getPropertiesSortedByValue = function(obj) {
    var arr = [];
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        arr.push({ 'k': prop,
                   'v': obj[prop]
                 });
      }
    }
    arr.sort(function(a,b) { return b.v - a.v; }); //sort descending!
    for(var i=0; i<arr.length; i++) {
      arr[i] = arr[i].k;
    }
    return arr;
  }
  
  function isOverflowWidth(node) {
    return true; //as the function is not working yet
//    return node.each(function() {
    var el = $(node);
    if (el.css("overflow") == "hidden") {
      var text = el.html(); //get the content
      var t = $(node.cloneNode(true)).hide()
                                     .css('position', 'absolute')
                                     .css('overflow', 'visible')
                                     .css('max-width', '')
                                     .css('display', 'block')
                                     .width('auto')
                                     .height(el.height());
      el.after(t);    
      console.debug(t);
      console.debug(el);
      function width() {
        console.debug(t.width() + " " + el.width());
        return t.width() > el.width();
      };
      var result = width();
      t.remove();
      return result;
    }
    else {
      console.debug("no hidden overflow");
      return false;
    }
  }//);
//  }
  
  this.generateTable = function generateTable() {
    //calculate the right table from the objects:
    this.tabledata = [];
    this.tagcounts = {};
    //iterate over the featureCollections
    for (var i=0; i<this.value.length; i++) {
      for (var j=0; j<this.value[i].features.length; j++) {
        var feature = this.value[i].features[j];
        //console.debug(feature);
        var item = $.extend({
            "__id__": feature.properties.id,
            "__type__": feature.properties.type,
            "__geo__": this.generateWKT(feature.geometry),
        }, feature.properties.tags );
        
        for(var tag in feature.properties.tags) {
          if (!this.tagcounts[tag]) {
            this.tagcounts[tag] = 0;
          }
          this.tagcounts[tag]++;
        }
        this.tabledata.push(item);
      }
    }
    console.debug(this.tagcounts);
    //flush the table:
    $("#datatable thead").empty();
    $("#datatable tbody").empty();
    //get the table column definitions:
    var headers = ['osm-id','type','geometry'];
    var tagColumns = this.getPropertiesSortedByValue(this.tagcounts);
    console.debug(tagColumns);
    headers  = headers.concat(tagColumns);
    var fields = ['__id__', '__type__', '__geo__'];
    fields = fields.concat(tagColumns);
    this.jsont = $("#datatable").jsonTable({
      head : headers, // Goes on the <thead>
      json : fields //json identities from the loaded json object
    });
    
    var options = {
                    source : this.tabledata, // Can be a URL or a JSON object array
                    rowClass : "rowClass", //(optional) Class to be applied
                    callback : function() {
                      // (optional) Do something when table is updated
                    }
                  };

    this.jsont.jsonTableUpdate(options);
    if ($.fn.DataTable.fnIsDataTable($("#datatable"))) {
      $("#datatable").fnDestroy();
    }
    $("#datatable").dataTable({"bJQueryUI": true });
    //set tooltips for all cells:
    
    $("#datatable td").filter(function() { 
                                console.debug(this);
                                var overflowing = isOverflowWidth(this); 
                                console.debug(overflowing);
                                return overflowing;
                              }
                             )
                      .tooltip({ content: function() { 
                                            return $(this).text() 
                                          }, 
                                 items: "td",
                                 tooltipClass: "table-tooltip"
                               });
  }

  return;
}
